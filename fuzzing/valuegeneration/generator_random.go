package valuegeneration

import (
	"math/big"
	"math/rand"
	"sync"

	"github.com/crytic/medusa/utils"
	"github.com/crytic/medusa/utils/randomutils"
	"github.com/ethereum/go-ethereum/common"
)

// RandomValueGenerator represents a ValueGenerator used to generate transaction fields and call arguments with values
// provided by a random number generator.
type RandomValueGenerator struct {
	// config describes the configuration defining value generation parameters.
	config *RandomValueGeneratorConfig

	// randomProvider offers a source of random data.
	randomProvider *rand.Rand
}

// RandomValueGeneratorConfig defines the parameters for a RandomValueGenerator.
type RandomValueGeneratorConfig struct {
	// GenerateRandomArrayMinSize defines the minimum size which a generated array should be.
	GenerateRandomArrayMinSize int
	// GenerateRandomArrayMaxSize defines the maximum size which a generated array should be.
	GenerateRandomArrayMaxSize int
	// GenerateRandomBytesMinSize defines the minimum size which a generated byte slice should be.
	GenerateRandomBytesMinSize int
	// GenerateRandomBytesMaxSize defines the maximum size which a generated byte slice should be.
	GenerateRandomBytesMaxSize int
	// GenerateRandomStringMinSize defines the minimum size which a generated string should be.
	GenerateRandomStringMinSize int
	// GenerateRandomStringMaxSize defines the maximum size which a generated string should be.
	GenerateRandomStringMaxSize int
}

// NewRandomValueGenerator creates a new RandomValueGenerator.
func NewRandomValueGenerator(config *RandomValueGeneratorConfig, randomProvider *rand.Rand) *RandomValueGenerator {
	// Create and return our generator
	generator := &RandomValueGenerator{
		config:         config,
		randomProvider: randomProvider,
	}
	return generator
}

// GenerateAddress generates a random address to use when populating inputs.
func (g *RandomValueGenerator) GenerateAddress() common.Address {
	// Generate random bytes of the address length, then convert it to an address.
	addressBytes := make([]byte, common.AddressLength)
	g.randomProvider.Read(addressBytes)
	return common.BytesToAddress(addressBytes)
}

// MutateAddress takes an address input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateAddress(addr common.Address) common.Address {
	// This value generator does not apply mutations.
	return addr
}

// GenerateArrayOfLength generates a random array length to use when populating inputs. This is used to determine how
// many elements a non-byte, non-string array should have.
func (g *RandomValueGenerator) GenerateArrayOfLength() int {
	rangeSize := uint64(g.config.GenerateRandomArrayMaxSize-g.config.GenerateRandomArrayMinSize) + 1
	return int(g.GenerateInteger(false, 16).Uint64()%rangeSize) + g.config.GenerateRandomArrayMinSize
}

// MutateArray takes a dynamic or fixed sized array as input, and returns a mutated value based off of the input.
// Returns the mutated value. If any element of the returned array is nil, the value generator will be called upon
// to generate it new.
func (g *RandomValueGenerator) MutateArray(value []any, fixedLength bool) []any {
	// This value generator does not apply mutations.
	return value
}

// GenerateBool generates a random bool to use when populating inputs.
func (g *RandomValueGenerator) GenerateBool() bool {
	return g.randomProvider.Uint32()%2 == 0
}

// MutateBool takes a boolean input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateBool(bl bool) bool {
	// This value generator does not apply mutations.
	return bl
}

// GenerateBytes generates a random dynamic-sized byte array to use when populating inputs.
func (g *RandomValueGenerator) GenerateBytes() []byte {
	rangeSize := uint64(g.config.GenerateRandomBytesMaxSize-g.config.GenerateRandomBytesMinSize) + 1
	b := make([]byte, int(g.randomProvider.Uint64()%rangeSize)+g.config.GenerateRandomBytesMinSize)
	g.randomProvider.Read(b)
	return b
}

// MutateBytes takes a dynamic-sized byte array input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateBytes(b []byte) []byte {
	// This value generator does not apply mutations.
	return b
}

// GenerateFixedBytes generates a random fixed-sized byte array to use when populating inputs.
func (g *RandomValueGenerator) GenerateFixedBytes(length int) []byte {
	b := make([]byte, length)
	g.randomProvider.Read(b)
	return b
}

// MutateFixedBytes takes a fixed-sized byte array input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateFixedBytes(b []byte) []byte {
	// This value generator does not apply mutations.
	return b
}

// GenerateString generates a random dynamic-sized string to use when populating inputs.
func (g *RandomValueGenerator) GenerateString() string {
	rangeSize := uint64(g.config.GenerateRandomStringMaxSize-g.config.GenerateRandomStringMinSize) + 1
	b := make([]byte, int(g.randomProvider.Uint64()%rangeSize)+g.config.GenerateRandomStringMinSize)
	g.randomProvider.Read(b)
	return string(b)
}

// MutateString takes a string input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateString(s string) string {
	// This value generator does not apply mutations.
	return s
}

// GenerateInteger generates a random integer to use when populating inputs.
func (g *RandomValueGenerator) GenerateInteger(signed bool, bitLength int) *big.Int {
	// Generate the various choices for an unsigned integer
	unsignedGenerationChooser := randomutils.NewWeightedRandomChooserWithRand[func(g *RandomValueGenerator, bitLength int) *big.Int](g.randomProvider, &sync.Mutex{})
	unsignedGenerationChooser.AddChoices(
		randomutils.NewWeightedRandomChoice(
			// Generate a random value between [0, 1024) with a 9% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				return new(big.Int).SetInt64(int64(g.randomProvider.Intn(1024)))
			},
			new(big.Int).SetUint64(2),
		),
		randomutils.NewWeightedRandomChoice(
			// Generate a random value between [0, 2^n - 5) with a 76% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				// Create upper bound (2^n - 5)
				upperBound := new(big.Int).Lsh(big.NewInt(1), uint(bitLength))
				upperBound.Sub(upperBound, big.NewInt(5))

				// Generate random number in range [0, upperBound)
				return new(big.Int).Rand(g.randomProvider, upperBound)
			},
			new(big.Int).SetUint64(16),
		),
		randomutils.NewWeightedRandomChoice(
			// Generate a random value between [2^n-5, 2^n - 1) with a 9% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				// Create 2^n first
				maxValue := new(big.Int).Lsh(big.NewInt(1), uint(bitLength))

				// Subtract a random number between 1 and 5 to get our expected range
				return maxValue.Sub(maxValue, big.NewInt(int64(1+g.randomProvider.Intn(5))))
			},
			new(big.Int).SetUint64(2),
		),
		randomutils.NewWeightedRandomChoice(
			// Generate a random value between [2^(n/2), 2^n) where n = n-5 with a 4% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				// Subtract 5 from the bit length to get the upper bound exponent
				bitLength = bitLength - 5
				if bitLength <= 0 {
					return new(big.Int).SetUint64(0)
				}

				// Create lower and upper bound
				lowerBound := new(big.Int).Lsh(big.NewInt(1), uint(bitLength/2))
				upperBound := new(big.Int).Lsh(big.NewInt(1), uint(bitLength))

				// Calculate range size (2^n - 2^(n/2))
				rangeSize := new(big.Int).Sub(upperBound, lowerBound)

				// Generate random number in range [0, rangeSize)
				result := new(big.Int).Rand(g.randomProvider, rangeSize)

				// Add min to shift into desired range [2^(n/2), 2^n)
				return result.Add(result, lowerBound)

			},
			new(big.Int).SetUint64(1),
		),
	)

	// Generate the various choices for a signed integer
	signedGenerationChooser := randomutils.NewWeightedRandomChooserWithRand[func(g *RandomValueGenerator, bitLength int) *big.Int](g.randomProvider, &sync.Mutex{})
	signedGenerationChooser.AddChoices(
		randomutils.NewWeightedRandomChoice(
			// Generate a random number between [-1023, 1023] with a 10% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				// Generate random number in range [0, 2047) (which covers -1023 to 1023)
				n := g.randomProvider.Intn(2047)

				// Shift the range from [0, 2048) to [-1023, 1024]
				return big.NewInt(int64(n - 1023))
			},
			new(big.Int).SetUint64(1),
		),
		randomutils.NewWeightedRandomChoice(
			// Generate a random number between [-2^n, 2^n-1] with a 90% chance
			func(g *RandomValueGenerator, bitLength int) *big.Int {
				// Fill a byte array of the appropriate size with random bytes
				b := make([]byte, bitLength/8)
				g.randomProvider.Read(b)

				// Create an unsigned integer.
				res := big.NewInt(0).SetBytes(b)

				// Constrain our integer bounds
				return utils.ConstrainIntegerToBitLength(res, true, bitLength)
			},
			new(big.Int).SetUint64(9),
		),
	)

	// If it is signed, choose a generator for a signed integer and return the result
	if signed {
		generatorFunc, err := signedGenerationChooser.Choose()
		if err != nil {
			panic(err)
		}
		return (*generatorFunc)(g, bitLength)
	}

	// Otherwise, choose a generator for an unsigned integer and return the result
	generatorFunc, err := unsignedGenerationChooser.Choose()
	if err != nil {
		panic(err)
	}
	return (*generatorFunc)(g, bitLength)
}

// MutateInteger takes an integer input and returns a mutated value based off the input.
func (g *RandomValueGenerator) MutateInteger(i *big.Int, signed bool, bitLength int) *big.Int {
	// This value generator does not apply mutations.
	return i
}
