package valuegeneration

import (
	"math/big"
	"math/rand"
	"sync"

	"github.com/crytic/medusa/utils"
	"github.com/crytic/medusa/utils/randomutils"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
)

// MutationalValueGenerator represents a ValueGenerator and ValueMutator for function inputs and call arguments. It
// leverages values from a ValueSet (e.g. AST literals) to generate new values or mutate existing ones.
type MutationalValueGenerator struct {
	// config describes the configuration defining value generation and mutation parameters.
	config *MutationalValueGeneratorConfig

	// valueSet contains a set of values which the ValueGenerator may use to aid in value generation and mutation
	// operations.
	valueSet *ValueSet

	// RandomValueGenerator is included to inherit from the random generator
	*RandomValueGenerator
}

// MutationalValueGeneratorConfig defines the operating parameters for a MutationalValueGenerator.
type MutationalValueGeneratorConfig struct {
	// MinMutationRounds describes the minimum amount of mutations which should occur when generating a value.
	// This parameter is used when generating a new value by mutating a value in the value set, or when mutating
	// an existing value.
	MinMutationRounds int
	// MaxMutationRounds describes the maximum amount of mutations which should occur when generating a value.
	// This parameter is used when generating a new value by mutating a value in the value set, or when mutating
	// an existing value.
	MaxMutationRounds int

	// GenerateRandomIntegerBias defines the probability in which an address generated by the value generator is
	// entirely random, rather than selected from the MutationalValueGenerator's ValueSet.
	// range is [0.0, 1.0].
	GenerateRandomAddressBias float32
	// GenerateRandomIntegerBias defines the probability in which an integer generated by the value generator is
	// entirely random, rather than mutated. Value range is [0.0, 1.0].
	GenerateRandomIntegerBias float32
	// GenerateRandomStringBias defines the probability in which a string generated by the value generator is entirely
	// random, rather than mutated. Value range is [0.0, 1.0].
	GenerateRandomStringBias float32
	// GenerateRandomBytesBias defines the probability in which a byte array generated by the value generator is
	// entirely random, rather than mutated. Value range is [0.0, 1.0].
	GenerateRandomBytesBias float32

	// MutateAddressProbability defines the probability in which an existing address value will be mutated by
	// the value generator. Value range is [0.0, 1.0].
	MutateAddressProbability float32
	// MutateArrayStructureProbability defines the probability in which an existing array value will be mutated by
	// the value generator. Value range is [0.0, 1.0].
	MutateArrayStructureProbability float32
	// MutateAddressProbability defines the probability in which an existing boolean value will be mutated by
	// the value generator. Value range is [0.0, 1.0].
	MutateBoolProbability float32
	// MutateBytesProbability defines the probability in which an existing dynamic-sized byte array value will be
	// mutated by the value generator. Value range is [0.0, 1.0].
	MutateBytesProbability float32
	// MutateFixedBytesProbability defines the probability in which an existing fixed-sized byte array value will be
	// mutated by the value generator. Value range is [0.0, 1.0].
	MutateFixedBytesProbability float32
	// MutateStringProbability defines the probability in which an existing string value will be mutated by
	// the value generator. Value range is [0.0, 1.0].
	MutateStringProbability float32
	// MutateIntegerProbability defines the probability in which an existing integer value will be mutated by
	// the value generator. Value range is [0.0, 1.0].
	MutateIntegerProbability float32

	// RandomValueGeneratorConfig is adhered to in this structure, to power the underlying RandomValueGenerator.
	*RandomValueGeneratorConfig
}

// NewMutationalValueGenerator creates a new MutationalValueGenerator using a provided ValueSet to seed base-values for
// mutation.
func NewMutationalValueGenerator(config *MutationalValueGeneratorConfig, valueSet *ValueSet, randomProvider *rand.Rand) *MutationalValueGenerator {
	// Create and return our generator
	generator := &MutationalValueGenerator{
		config:               config,
		valueSet:             valueSet,
		RandomValueGenerator: NewRandomValueGenerator(config.RandomValueGeneratorConfig, randomProvider),
	}

	// Ensure some initial values this mutator will depend on for basic mutations to the set.
	generator.valueSet.AddInteger(big.NewInt(0))
	generator.valueSet.AddInteger(big.NewInt(1))
	generator.valueSet.AddInteger(big.NewInt(-1))
	generator.valueSet.AddInteger(big.NewInt(2))
	return generator
}

// mutateIntegerInternal mutates an integer with a given sign and bit length.
func (g *MutationalValueGenerator) mutateIntegerInternal(i *big.Int, signed bool, bitLength int) *big.Int {
	// If the integer is nil or it's zero, return zero
	if i == nil || i.Sign() == 0 {
		return big.NewInt(0)
	}

	// Get the minimum and maximum values for this integer type
	min, max := utils.GetIntegerConstraints(signed, bitLength)

	// Pick a random value between `[0, abs(i)]`
	delta := big.NewInt(0).Rand(g.randomProvider, big.NewInt(0).Abs(i))

	// Decide whether we are going to add or subtract this delta
	if g.randomProvider.Float32() <= 0.5 {
		// We will add the delta
		i.Add(i, delta)
	} else {
		// We will subtract the delta
		i.Sub(i, delta)
	}

	// Bound the integer to its constraints and return it
	return utils.ConstrainIntegerToBounds(i, min, max)
}

// mutateListLikeObject mutates a list-like object (e.g. byte array, string, etc). The function will utilize one
// of four different mutation methods to mutate the list-like input. Returns the mutated list.
func mutateListLikeObject[T any](g *MutationalValueGenerator, list []T) []T {
	// There are four different mutation methods for list-like objects.
	listMutationMethods := randomutils.NewWeightedRandomChooserWithRand[func(g *MutationalValueGenerator, list []T) []T](g.randomProvider, &sync.Mutex{})
	listMutationMethods.AddChoices(
		randomutils.NewWeightedRandomChoice(
			// No-op: Return the original list as-is with a 1/31 chance
			func(g *MutationalValueGenerator, list []T) []T {
				return list
			},

			new(big.Int).SetUint64(1),
		),
		randomutils.NewWeightedRandomChoice(
			// Delete: Remove a random element from the list with a 10/31 chance
			func(g *MutationalValueGenerator, list []T) []T {
				idx := g.randomProvider.Intn(len(list))
				return append(list[:idx], list[idx+1:]...)
			},
			new(big.Int).SetUint64(10),
		),
		randomutils.NewWeightedRandomChoice(
			// Expand: Expand the list by expanding a random element from the random list
			// a random number of times with a 10/31 chance
			func(g *MutationalValueGenerator, list []T) []T {
				// We also do not want to expand lists if they are already greater than 32 elements
				if len(list) >= 32 {
					return list
				}
				// Generate a random index to replicate
				idx := g.randomProvider.Intn(len(list))
				// Generate a random number of times to replicate the element
				num := g.randomProvider.Intn(min(32, len(list))) + 1

				// Create a new list to store the replicated elements
				expandedList := make([]T, 0)
				// Append the elements before the index
				expandedList = append(expandedList, list[:idx]...)

				// Append the element of choice num time
				for i := 0; i < num; i++ {
					expandedList = append(expandedList, list[idx])
				}

				// Append the elements after the index
				expandedList = append(expandedList, list[idx+1:]...)
				return expandedList
			},
			new(big.Int).SetUint64(10),
		),
		randomutils.NewWeightedRandomChoice(
			// Swap: Swap two random elements in the list with a 10/31 chance
			func(g *MutationalValueGenerator, list []T) []T {
				idx1 := g.randomProvider.Intn(len(list))
				idx2 := g.randomProvider.Intn(len(list))
				list[idx1], list[idx2] = list[idx2], list[idx1]
				return list
			},
			new(big.Int).SetUint64(10),
		),
	)

	// Choose a random mutation method
	// We shouldn't have any errors here so ignore the error
	mutationMethod, _ := listMutationMethods.Choose()

	// Apply the mutation method to the list
	return (*mutationMethod)(g, list)
}

// GenerateAddress obtains an existing address from its underlying value set or generates a random one.
func (g *MutationalValueGenerator) GenerateAddress() common.Address {
	// If our bias directs us to or if we have nothing in the value set, use the random generator instead
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.GenerateRandomAddressBias || len(g.valueSet.Addresses()) == 0 {
		return g.RandomValueGenerator.GenerateAddress()
	}

	// Obtain our addresses from our value set.
	addresses := g.valueSet.Addresses()

	// Select a random address from our set of addresses.
	address := addresses[g.randomProvider.Intn(len(addresses))]
	return address
}

// MutateAddress takes an address input and mutates it.
func (g *MutationalValueGenerator) MutateAddress(addr common.Address) common.Address {
	// Currently, we do not mutate addresses and we return it as-is.
	return addr
}

// MutateArray takes a dynamic or fixed sized array as input, and returns a mutated value based off of the input.
// The ABI type of the array is also provided in case new values need to be generated. Returns the mutated value.
func (g *MutationalValueGenerator) MutateArray(array []any, fixedLength bool, abiType *abi.Type) []any {
	// Determine whether to perform mutations against this input or just return it as-is.
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision > g.config.MutateArrayStructureProbability {
		return array
	}
	// Calculate length of the array
	length := len(array)

	// Mutate the array
	mutatedArray := mutateListLikeObject(g, array)

	// If it's a dynamic length array, we can return early
	if !fixedLength {
		return mutatedArray
	}

	// If the mutated array is too long, truncate it
	if len(mutatedArray) > length {
		return mutatedArray[:length]
	}

	// If the mutated array is too short, pad it with newly generated elements
	for i := len(mutatedArray); i < length; i++ {
		mutatedArray = append(mutatedArray, GenerateAbiValue(g, abiType))
	}

	// Return the mutated array
	return mutatedArray
}

// MutateBool takes a boolean input and returns a mutated value based off the input.
func (g *MutationalValueGenerator) MutateBool(bl bool) bool {
	// We do not really mutate booleans, so we just flip the coin again
	return g.RandomValueGenerator.GenerateBool()
}

// GenerateBytes generates bytes and returns them.
func (g *MutationalValueGenerator) GenerateBytes() []byte {
	// If our bias directs us to or if we have nothing in the value set, use the random generator instead
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.GenerateRandomBytesBias || len(g.valueSet.Bytes()) == 0 {
		return g.RandomValueGenerator.GenerateBytes()
	}

	// Obtain our byte arrays/slices from our value set.
	byteSlices := g.valueSet.Bytes()

	// Select a random byte slice from our set of byte slices.
	byteSlice := byteSlices[g.randomProvider.Intn(len(byteSlices))]

	return byteSlice
}

// MutateBytes takes a dynamic-sized byte array input and returns a mutated value based off the input.
func (g *MutationalValueGenerator) MutateBytes(b []byte) []byte {
	// Determine whether to perform mutations against this input or just return it as-is.
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.MutateBytesProbability {
		return mutateListLikeObject(g, b)
	}

	return b
}

// MutateFixedBytes takes a fixed-sized byte array input and returns a mutated value based off the input.
func (g *MutationalValueGenerator) MutateFixedBytes(b []byte) []byte {
	// Determine whether to perform mutations against this input or just return it as-is.
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision > g.config.MutateFixedBytesProbability {
		// Return the original byte array
		return b
	}
	// Capture the original length of the byte array
	length := len(b)

	// Now, mutate the fixed bytes
	mutatedFixedBytes := mutateListLikeObject(g, b)

	// If the array is too long, truncate it
	if len(mutatedFixedBytes) > length {
		return mutatedFixedBytes[:length]
	}
	// The mutated fixed bytes is too short, pad it with random bytes
	if len(mutatedFixedBytes) < length {
		randomBytes := g.RandomValueGenerator.GenerateFixedBytes(length - len(mutatedFixedBytes))
		mutatedFixedBytes = append(mutatedFixedBytes, randomBytes...)
	}

	return mutatedFixedBytes
}

// GenerateFixedBytes generates a fixed-sized byte array to use when populating inputs.
func (g *MutationalValueGenerator) GenerateFixedBytes(length int) []byte {
	// If our bias directs us to or if we have nothing in the value set, use the random generator instead
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.GenerateRandomBytesBias || len(g.valueSet.Bytes()) == 0 {
		return g.RandomValueGenerator.GenerateFixedBytes(length)
	}

	// Obtain our byte arrays/slices from our value set.
	byteArrays := g.valueSet.Bytes()

	// Select a random byte array from our set of byte arrays.
	byteArray := byteArrays[g.randomProvider.Intn(len(byteArrays))]

	// If the array is smaller than the requested length, then pad the array with zeros
	if len(byteArray) < length {
		paddedZeros := make([]byte, length-len(byteArray))
		byteArray = append(byteArray, paddedZeros...)
	}

	// Similarly, if it's too long, truncate it
	if len(byteArray) > length {
		return byteArray[:length]
	}
	return byteArray
}

// GenerateString generates a new string and returns it.
func (g *MutationalValueGenerator) GenerateString() string {
	// If our bias directs us to or if we have nothing in the value set, use the random generator instead
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.GenerateRandomStringBias || len(g.valueSet.Strings()) == 0 {
		return g.RandomValueGenerator.GenerateString()
	}

	// Obtain our strings from our value set.
	strings := g.valueSet.Strings()

	// Select a random string from our set of strings.
	string := strings[g.randomProvider.Intn(len(strings))]
	return string
}

// MutateString takes a string input and returns a mutated value based off the input.
func (g *MutationalValueGenerator) MutateString(s string) string {
	// Determine whether to perform mutations against this input or just return it as-is.
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.MutateStringProbability {
		mutatedStringAsRunes := mutateListLikeObject(g, []rune(s))
		return string(mutatedStringAsRunes)
	}

	return s
}

// GenerateInteger generates an integer of the provided properties and returns a big.Int representing it.
func (g *MutationalValueGenerator) GenerateInteger(signed bool, bitLength int) *big.Int {
	// If our bias directs us to or if we have nothing in the value set, use the random generator instead
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.GenerateRandomIntegerBias || len(g.valueSet.Integers()) == 0 {
		return g.RandomValueGenerator.GenerateInteger(signed, bitLength)
	}

	// Obtain our integers from our value set.
	integers := g.valueSet.Integers()

	// Select a random integer from our set of integers.
	integer := integers[g.randomProvider.Intn(len(integers))]
	return integer
}

// MutateInteger takes an integer input and applies optional mutations to the provided value.
// Returns an optionally mutated copy of the input.
func (g *MutationalValueGenerator) MutateInteger(i *big.Int, signed bool, bitLength int) *big.Int {
	// Determine whether to perform mutations against this input or just return it as-is.
	randomGeneratorDecision := g.randomProvider.Float32()
	if randomGeneratorDecision < g.config.MutateIntegerProbability {
		return g.mutateIntegerInternal(i, signed, bitLength)
	}
	return i
}
