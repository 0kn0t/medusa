package fuzzing

import (
	"fmt"
	"github.com/trailofbits/medusa/fuzzing/calls"
	"github.com/trailofbits/medusa/fuzzing/valuegeneration"
	"github.com/trailofbits/medusa/utils/randomutils"
	"math/big"
)

// CallSequenceGenerator generates call sequences iteratively per element, for use in fuzzing campaigns.
type CallSequenceGenerator struct {
	// worker describes the parent FuzzerWorker using this mutator. Calls will be generated against deployed contract
	// methods known to the worker.
	worker *FuzzerWorker

	// baseSequence describes the internal call sequence generated by NewSequence to use as a base when providing
	// potentially further mutated values with PopSequenceElement iteratively.
	baseSequence calls.CallSequence

	// fetchIndex describes the current position in the baseSequence which defines the next element to be mutated and
	// returned when calling PopSequenceElement.
	fetchIndex int

	// prefetchModifyCallFunc describes the method to use to mutate the next indexed call sequence element, prior
	// to its fetching by PopSequenceElement.
	prefetchModifyCallFunc PrefetchModifyCallFunc

	// mutationStrategyChooser is a weighted random selector of functions that prepare the CallSequenceGenerator with
	// a baseSequence derived from corpus entries.
	mutationStrategyChooser *randomutils.WeightedRandomChooser[CallSequenceGeneratorMutationStrategy]
}

// CallSequenceGeneratorFunc defines a method used to populate a provided call sequence with generated calls.
// Returns an optional PrefetchModifyCallFunc to be executed prior to the fetching of each element, or an error if
// one occurs.
type CallSequenceGeneratorFunc func(sequenceGenerator *CallSequenceGenerator, sequence calls.CallSequence) error

// PrefetchModifyCallFunc defines a method used to modify a call sequence element before being fetched from this
// provider for use.
// Returns an error if one occurs.
type PrefetchModifyCallFunc func(sequenceGenerator *CallSequenceGenerator, element *calls.CallSequenceElement) error

// CallSequenceGeneratorMutationStrategy defines a structure for a mutation strategy used by a CallSequenceGenerator.
type CallSequenceGeneratorMutationStrategy struct {
	// CallSequenceGeneratorFunc describes a method used to populate a provided call sequence.
	CallSequenceGeneratorFunc CallSequenceGeneratorFunc

	// PrefetchModifyCallFunc defines a method used to modify a call sequence element before being fetched.
	PrefetchModifyCallFunc PrefetchModifyCallFunc
}

// NewCallSequenceGenerator creates a CallSequenceGenerator to generate call sequences for use in fuzzing campaigns.
func NewCallSequenceGenerator(worker *FuzzerWorker) *CallSequenceGenerator {
	generator := &CallSequenceGenerator{
		worker:                  worker,
		mutationStrategyChooser: randomutils.NewWeightedRandomChooser[CallSequenceGeneratorMutationStrategy](),
	}

	generator.mutationStrategyChooser.AddChoices(
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: callSeqGenFuncCorpusHead,
				PrefetchModifyCallFunc:    nil,
			},
			big.NewInt(800),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: callSeqGenFuncCorpusTail,
				PrefetchModifyCallFunc:    nil,
			},
			big.NewInt(100),
		),
	)

	return generator
}

// NewSequence prepares the CallSequenceGenerator so that PopSequenceElement can be called to obtain each element of the
// call sequence, as specified by the provided length.
func (g *CallSequenceGenerator) NewSequence(length int) error {
	// Reset the state of our generator.
	g.baseSequence = make(calls.CallSequence, length)
	g.fetchIndex = 0
	g.prefetchModifyCallFunc = nil

	// Next, we'll decide whether to create a new call sequence or mutating existing corpus call sequences.
	// Any entries we leave as nil will be populated by a newly generated call prior to being fetched from this
	// provider.

	// If this provider has no corpus mutation methods or corpus call sequences, we return a call sequence with
	// nil elements to signal that we want an entirely new sequence.
	if g.mutationStrategyChooser.ChoiceCount() == 0 || g.worker.fuzzer.corpus.ActiveCallSequenceCount() == 0 {
		return nil
	}

	// TODO: Move this constant to a config
	const sequenceGeneratorNewSequenceProbability = float32(0.3)

	// Determine whether we will generate a corpus based mutated sequence, or an entirely new one.
	if g.worker.randomProvider.Float32() > sequenceGeneratorNewSequenceProbability {
		// Get a random mutator function and call it.
		corpusMutationFunc, err := g.mutationStrategyChooser.Choose()
		if err != nil {
			return fmt.Errorf("could not generate a corpus mutation derived call sequence due to an error obtaining a mutation method: %v", err)
		}

		// If we have a corpus mutation method, call it to generate our base sequence, then set the pre-fetch modify
		// call function.
		if corpusMutationFunc != nil && corpusMutationFunc.CallSequenceGeneratorFunc != nil {
			err = corpusMutationFunc.CallSequenceGeneratorFunc(g, g.baseSequence)
			if err != nil {
				return fmt.Errorf("could not generate a corpus mutation derived call sequence due to an error executing a mutation method: %v", err)
			}
			g.prefetchModifyCallFunc = corpusMutationFunc.PrefetchModifyCallFunc
		}
	}
	return nil
}

// PopSequenceElement obtains the next element for our call sequence requested by NewSequence. If there are no elements
// left to return, this method returns an error.
func (g *CallSequenceGenerator) PopSequenceElement() (*calls.CallSequenceElement, error) {
	// If the call sequence length is zero, there is no work to be done.
	if g.fetchIndex >= len(g.baseSequence) {
		return nil, fmt.Errorf("call sequence element could not be generated as there are no calls to make")
	}

	// Obtain our base call element
	element := g.baseSequence[g.fetchIndex]

	// If it is nil, we generate an entirely new call. Otherwise, we apply pre-execution modifications.
	var err error
	if element == nil {
		element, err = g.generateNewElement()
		if err != nil {
			return nil, err
		}
	} else {
		// We have an element, if our generator set a post-call modify for this function, execute it now to modify
		// our call prior to return. This allows mutations to be applied on a per-call time frame, rather than
		// per-sequence, making use of the most recent runtime data.
		if g.prefetchModifyCallFunc != nil {
			err = g.prefetchModifyCallFunc(g, element)
			if err != nil {
				return nil, err
			}
		}
	}

	// Update our base sequence, advance our position, and return the processed element from this round.
	g.baseSequence[g.fetchIndex] = element
	g.fetchIndex++
	return element, nil
}

// generateNewElement generates a new call sequence element which targets a state changing method in a contract
// deployed to the CallSequenceGenerator's parent FuzzerWorker chain, with fuzzed call data.
// Returns the call sequence element, or an error if one was encountered.
func (g *CallSequenceGenerator) generateNewElement() (*calls.CallSequenceElement, error) {
	// Verify we have state changing methods to call
	if len(g.worker.stateChangingMethods) == 0 {
		return nil, fmt.Errorf("cannot generate fuzzed tx as there are no state changing methods to call")
	}

	// Select a random method and sender
	selectedMethod := &g.worker.stateChangingMethods[g.worker.randomProvider.Intn(len(g.worker.stateChangingMethods))]
	selectedSender := g.worker.fuzzer.senders[g.worker.randomProvider.Intn(len(g.worker.fuzzer.senders))]

	// Generate fuzzed parameters for the function call
	args := make([]any, len(selectedMethod.Method.Inputs))
	for i := 0; i < len(args); i++ {
		// Create our fuzzed parameters.
		input := selectedMethod.Method.Inputs[i]
		args[i] = valuegeneration.GenerateAbiValue(g.worker.valueGenerator, &input.Type)
	}

	// If this is a payable function, generate value to send
	var value *big.Int
	value = big.NewInt(0)
	if selectedMethod.Method.StateMutability == "payable" {
		value = g.worker.valueGenerator.GenerateInteger(false, 64)
	}

	// Create our message using the provided parameters.
	// We fill out some fields and populate the rest from our TestChain properties.
	// TODO: We likely want to make gasPrice fluctuate within some sensible range here.
	msg := calls.NewCallMessageWithAbiValueData(selectedSender, &selectedMethod.Address, 0, value, g.worker.fuzzer.config.Fuzzing.TransactionGasLimit, nil, nil, nil, &calls.CallMessageDataAbiValues{
		Method:      &selectedMethod.Method,
		InputValues: args,
	})
	msg.FillFromTestChainProperties(g.worker.chain)

	// Determine our delay values for this element
	// TODO: If we want more txs to be added together in a block, we should add a switch to make a 0 block number
	//  jump occur more often here.
	blockNumberDelay := uint64(0)
	blockTimestampDelay := uint64(0)
	if g.worker.fuzzer.config.Fuzzing.MaxBlockNumberDelay > 0 {
		blockNumberDelay = g.worker.valueGenerator.GenerateInteger(false, 64).Uint64() % (g.worker.fuzzer.config.Fuzzing.MaxBlockNumberDelay + 1)
	}
	if g.worker.fuzzer.config.Fuzzing.MaxBlockTimestampDelay > 0 {
		blockTimestampDelay = g.worker.valueGenerator.GenerateInteger(false, 64).Uint64() % (g.worker.fuzzer.config.Fuzzing.MaxBlockTimestampDelay + 1)
	}

	// For each block we jump, we need a unique time stamp for chain semantics, so if our block number jump is too small,
	// while our timestamp jump is larger, we cap it.
	if blockNumberDelay > blockTimestampDelay {
		if blockTimestampDelay == 0 {
			blockNumberDelay = 0
		} else {
			blockNumberDelay %= blockTimestampDelay
		}
	}

	// Return our call sequence element.
	return calls.NewCallSequenceElement(selectedMethod.Contract, msg, blockNumberDelay, blockTimestampDelay), nil
}

// callSeqGenFuncCorpusHead is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a sequence
// whose head is based off of an existing corpus call sequence.
// Returns an error if one occurs.
func callSeqGenFuncCorpusHead(sequenceGenerator *CallSequenceGenerator, sequence calls.CallSequence) error {
	// Obtain a call sequence from the corpus
	corpusSequence, err := sequenceGenerator.worker.fuzzer.corpus.RandomCallSequence()
	if err != nil {
		return fmt.Errorf("could not obtain corpus call sequence for tail mutation: %v", err)
	}

	// Determine a random position to slice the call sequence.
	maxLength := len(sequence)
	if len(corpusSequence) < maxLength {
		maxLength = len(corpusSequence)
	}
	copy(sequence, corpusSequence[:maxLength])

	return nil
}

// callSeqGenFuncCorpusTail is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a sequence
// whose tail is based off of an existing corpus call sequence.
// Returns an error if one occurs.
func callSeqGenFuncCorpusTail(sequenceGenerator *CallSequenceGenerator, sequence calls.CallSequence) error {
	// Obtain a call sequence from the corpus
	corpusSequence, err := sequenceGenerator.worker.fuzzer.corpus.RandomCallSequence()
	if err != nil {
		return fmt.Errorf("could not obtain corpus call sequence for tail mutation: %v", err)
	}

	// Determine a random position to slice the call sequence.
	maxLength := len(sequence)
	if len(corpusSequence) < maxLength {
		maxLength = len(corpusSequence)
	}
	targetLength := sequenceGenerator.worker.randomProvider.Intn(maxLength) + 1
	copy(sequence[len(sequence)-targetLength:], corpusSequence[len(corpusSequence)-targetLength:])

	return nil
}

// prefetchModifyCallFuncMutate is a PrefetchModifyCallFunc, called by a CallSequenceGenerator to apply mutations
// to a call sequence element, prior to it being fetched.
// Returns an error if one occurs.
func prefetchModifyCallFuncMutate(sequenceGenerator *CallSequenceGenerator, element *calls.CallSequenceElement) error {
	// TODO: We'll want to mutate the underlying ABI call data.
	return nil
}
